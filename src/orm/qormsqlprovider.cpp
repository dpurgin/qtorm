#include "qormsqlprovider.h"

#include "qormerror.h"
#include "qormentitymetadata.h"
#include "qormpropertymapping.h"
#include "qormsqlconfiguration.h"

#include <QDebug>
#include <QMetaObject>
#include <QMetaProperty>
#include <QObject>
#include <QSqlDatabase>
#include <QSqlError>
#include <QSqlQuery>

QT_BEGIN_NAMESPACE

class QOrmSqlProviderPrivate
{
    friend class QOrmSqlProvider;

    explicit QOrmSqlProviderPrivate(const QOrmSqlConfiguration& configuration)
        : m_sqlConfiguration{configuration}
    {
    }

    QSqlDatabase m_database;
    QOrmSqlConfiguration m_sqlConfiguration;
    QHash<QString, QOrmEntityMetadata> m_entityMetadataCache;
    QSet<QString> m_schemaSyncCache;

    Q_REQUIRED_RESULT
    QString toSqlType(QVariant::Type type);

    Q_REQUIRED_RESULT
    QOrmError lastDatabaseError() const;

    Q_REQUIRED_RESULT
    QSqlQuery prepareAndExecute(const QString& statement, const QVariantMap& parameters);

    Q_REQUIRED_RESULT
    const QOrmEntityMetadata& entityMetadata(const QMetaObject& qMetaObject);

    Q_REQUIRED_RESULT
    QVariant propertyValue(QObject* entityInstance, const QString& value)
    {
        return entityInstance->property(value.toUtf8().data());
    }

    void setPropertyValue(QObject* entityInstance, const QString& property, const QVariant& value)
    {
        entityInstance->setProperty(property.toUtf8().data(), value);
    }

    QOrmError ensureSchemaSynchronized(const QOrmEntityMetadata& entityMetadata);
    QOrmError recreateSchema(const QOrmEntityMetadata& entityMetadata);
    QOrmError updateSchema(const QOrmEntityMetadata& entityMetadata);
    QOrmError validateSchema(const QOrmEntityMetadata& validateSchema);
};

QString QOrmSqlProviderPrivate::toSqlType(QVariant::Type type)
{
    // SQLite data types: https://sqlite.org/datatype3.html
    switch (type)
    {
        case QVariant::Int:
        case QVariant::UInt:
        case QVariant::LongLong:
        case QVariant::ULongLong:
            return QStringLiteral("INTEGER");

        case QVariant::Double:
            return QStringLiteral("REAL");

        case QVariant::Bool:
        case QVariant::Date:
        case QVariant::Time:
        case QVariant::DateTime:
            return QStringLiteral("NUMERIC");

        case QVariant::Char:
        case QVariant::String:
            return QStringLiteral("TEXT");

        default:
            return QStringLiteral("BLOB");
    }
}

QOrmError QOrmSqlProviderPrivate::lastDatabaseError() const
{
    return QOrmError{QOrm::Error::Provider, m_database.lastError().text()};
}

QSqlQuery QOrmSqlProviderPrivate::prepareAndExecute(const QString& statement,
                                                    const QVariantMap& parameters = {})
{
    QSqlQuery query{m_database};

    if (m_sqlConfiguration.verbose())
        qDebug() << "Executing:" << statement;

    if (!query.prepare(statement))
        return query;

    if (!parameters.isEmpty())
    {
        if (m_sqlConfiguration.verbose())
            qDebug() << "Bound parameters:" << parameters;

        for (auto it = parameters.begin(); it != parameters.end(); ++it)
            query.bindValue(it.key(), it.value());
    }

    query.exec();

    return query;
}

const QOrmEntityMetadata& QOrmSqlProviderPrivate::entityMetadata(const QMetaObject& qMetaObject)
{
    QString className = QString::fromUtf8(qMetaObject.className());

    if (!m_entityMetadataCache.contains(className))
    {
        QOrmEntityMetadata entityMetadata;
        entityMetadata.setClassName(QString::fromUtf8(qMetaObject.className()));
        entityMetadata.setTableName(QString::fromUtf8(qMetaObject.className()));

        for (int i = 0; i < qMetaObject.propertyCount(); ++i)
        {
            QOrmPropertyMapping propertyMapping;

            QMetaProperty property = qMetaObject.property(i);

            // skip all properties of QObject
            if (property.enclosingMetaObject() == &QObject::staticMetaObject)
                continue;

            propertyMapping.setClassPropertyName(QString::fromUtf8(property.name()));
            propertyMapping.setTableFieldName(QString::fromUtf8(property.name()));
            propertyMapping.setDataType(property.type());

            if (propertyMapping.classPropertyName().compare("id", Qt::CaseInsensitive) == 0)
            {
                propertyMapping.setIsObjectId(true);
                propertyMapping.setIsAutogenerated(true);
                entityMetadata.setObjectIdPropertyMapping(propertyMapping);
            }

            entityMetadata.addPropertyMapping(std::move(propertyMapping));
        }

        m_entityMetadataCache[className] = entityMetadata;
    }

    return m_entityMetadataCache[className];
}

QOrmError QOrmSqlProviderPrivate::ensureSchemaSynchronized(const QOrmEntityMetadata& entityMetadata)
{
    QOrmError result{QOrm::Error::None, ""};

    if (m_sqlConfiguration.schemaMode() != QOrmSqlConfiguration::SchemaMode::Bypass &&
            !m_schemaSyncCache.contains(entityMetadata.className()))
    {
        switch (m_sqlConfiguration.schemaMode())
        {
            case QOrmSqlConfiguration::SchemaMode::Recreate:
                result = recreateSchema(entityMetadata);
                break;

            case QOrmSqlConfiguration::SchemaMode::Update:
                result = updateSchema(entityMetadata);
                break;

            case QOrmSqlConfiguration::SchemaMode::Validate:
                result = validateSchema(entityMetadata);
                break;

            case QOrmSqlConfiguration::SchemaMode::Bypass:
                break;
        }

        if (result.error() == QOrm::Error::None)
            m_schemaSyncCache.insert(entityMetadata.className());
    }

    return result;
}

QOrmError QOrmSqlProviderPrivate::recreateSchema(const QOrmEntityMetadata& entityMetadata)
{
    Q_ASSERT(m_database.isOpen());

    if (m_database.tables().contains(entityMetadata.tableName()))
    {
        QString statement = QString{"DROP TABLE %1"}.arg(entityMetadata.tableName());

        QSqlQuery query = prepareAndExecute(statement);

        if (query.lastError().type() != QSqlError::NoError)
            return QOrmError{QOrm::Error::UnsynchronizedSchema, query.lastError().text()};
    }

    QStringList fields;

    for (const QOrmPropertyMapping& mapping: entityMetadata.propertyMappings())
    {
        QStringList columnDefs = { mapping.tableFieldName(), toSqlType(mapping.dataType()) };

        if (mapping.isObjectId())
            columnDefs.push_back("PRIMARY KEY");

        if (mapping.isAutogenerated())
            columnDefs.push_back("AUTOINCREMENT");

        fields.push_back(columnDefs.join(' '));
    }

    QString fieldsStr = fields.join(',');

    QString statement = QString::fromUtf8("CREATE TABLE %1(%2)")
                        .arg(entityMetadata.tableName(), fieldsStr);

    QSqlQuery query = prepareAndExecute(statement);

    if (query.lastError().type() != QSqlError::NoError)
        return QOrmError{QOrm::Error::UnsynchronizedSchema, query.lastError().text()};

    return QOrmError{QOrm::Error::None, ""};
}

QOrmError QOrmSqlProviderPrivate::updateSchema(const QOrmEntityMetadata& entityMetadata)
{
    return QOrmError{QOrm::Error::UnsynchronizedSchema, "Not implemented"};
}

QOrmError QOrmSqlProviderPrivate::validateSchema(const QOrmEntityMetadata& validateSchema)
{
    return QOrmError{QOrm::Error::UnsynchronizedSchema, "Not implemented"};
}

QOrmSqlProvider::QOrmSqlProvider(const QOrmSqlConfiguration& sqlConfiguration)
    : QOrmAbstractProvider{},
      d_ptr{new QOrmSqlProviderPrivate{sqlConfiguration}}
{
}

QOrmSqlProvider::~QOrmSqlProvider()
{
    delete d_ptr;
}

QOrmError QOrmSqlProvider::connectToBackend()
{
    Q_D(QOrmSqlProvider);

    if (!d->m_database.isOpen())
    {
        d->m_database = QSqlDatabase::addDatabase(d->m_sqlConfiguration.driverName());
        d->m_database.setConnectOptions(d->m_sqlConfiguration.connectOptions());
        d->m_database.setHostName(d->m_sqlConfiguration.hostName());
        d->m_database.setDatabaseName(d->m_sqlConfiguration.databaseName());
        d->m_database.setPassword(d->m_sqlConfiguration.password());
        d->m_database.setPort(d->m_sqlConfiguration.port());
        d->m_database.setUserName(d->m_sqlConfiguration.userName());

        if (!d->m_database.open())
            return d->lastDatabaseError();
    }

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::disconnectFromBackend()
{
    Q_D(QOrmSqlProvider);

    d->m_database.close();

    return QOrmError{QOrm::Error::None, {}};
}

bool QOrmSqlProvider::isConnectedToBackend()
{
    Q_D(QOrmSqlProvider);

    return d->m_database.isOpen();
}

QOrmError QOrmSqlProvider::beginTransaction()
{
    Q_D(QOrmSqlProvider);

    if (!d->m_database.transaction())
    {
        QSqlError error = d->m_database.lastError();

        if (error.type() != QSqlError::NoError)
            return d->lastDatabaseError();
        else
            return QOrmError{QOrm::Error::Other, QStringLiteral("Unable to start transaction")};
    }

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::commitTransaction()
{
    Q_D(QOrmSqlProvider);

    if (!d->m_database.commit())
    {
        QSqlError error = d->m_database.lastError();

        if (error.type() != QSqlError::NoError)
            return d->lastDatabaseError();
        else
            return QOrmError{QOrm::Error::Other, QStringLiteral("Unable to commit transaction")};
    }

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::rollbackTransaction()
{
    Q_D(QOrmSqlProvider);

    if (!d->m_database.rollback())
    {
        QSqlError error = d->m_database.lastError();

        if (error.type() != QSqlError::NoError)
            return d->lastDatabaseError();
        else
            return QOrmError{QOrm::Error::Other, QStringLiteral("Unable to rollback transaction")};
    }

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::create(QObject* entityInstance, const QMetaObject& qMetaObject)
{
    Q_D(QOrmSqlProvider);

    const QOrmEntityMetadata& entityMeta = d->entityMetadata(qMetaObject);

    QOrmError error = d->ensureSchemaSynchronized(entityMeta);

    if (error.error() != QOrm::Error::None)
    {
        return error;
    }

    QStringList fieldsList;
    QStringList valuesList;
    QVariantMap parameters;

    for (const QOrmPropertyMapping& propertyMapping: entityMeta.propertyMappings())
    {
        if (propertyMapping.isAutogenerated())
            continue;

        fieldsList.push_back(propertyMapping.tableFieldName());
        valuesList.push_back(':' % propertyMapping.tableFieldName());
        parameters[':' % propertyMapping.tableFieldName()] =
                d->propertyValue(entityInstance, propertyMapping.classPropertyName());
    }

    QString fieldsStr = fieldsList.join(',');
    QString valuesStr = valuesList.join(',');

    QString statement = QStringLiteral("INSERT INTO %1(%2) VALUES(%3)")
                        .arg(entityMeta.tableName(), fieldsStr, valuesStr);


    QSqlQuery query = d->prepareAndExecute(statement, parameters);

    if (query.lastError().type() != QSqlError::NoError)
        return QOrmError{QOrm::Error::Provider, query.lastError().text()};

    // Update autogenerated ID if any
    if (entityMeta.objectIdPropertyMapping().isAutogenerated())
    {
        d->setPropertyValue(entityInstance,
                            entityMeta.objectIdPropertyMapping().classPropertyName(),
                            query.lastInsertId());
    }

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::read(const QOrmQuery& query)
{
    Q_UNUSED(query)

    return QOrmError{QOrm::Error::Other, QStringLiteral("Not implemented")};
}

QOrmError QOrmSqlProvider::update(QObject* entityInstance, const QMetaObject& qMetaObject)
{
    Q_D(QOrmSqlProvider);

    const QOrmEntityMetadata& entityMeta = d->entityMetadata(qMetaObject);
    const QOrmPropertyMapping& objectIdPropertyMapping = entityMeta.objectIdPropertyMapping();

    QStringList setList;
    QVariantMap parameters;

    for (const QOrmPropertyMapping& propertyMapping: entityMeta.propertyMappings())
    {
        parameters[':' % propertyMapping.tableFieldName()] =
                d->propertyValue(entityInstance, propertyMapping.classPropertyName());

        if (propertyMapping.isAutogenerated())
            continue;

        setList.push_back(QString{"%1 = :%1"}.arg(propertyMapping.tableFieldName()));
    }

    QString setStr = setList.join(',');
    QString whereStr = QString{"%1 = :%1"}
                       .arg(objectIdPropertyMapping.tableFieldName());

    QString statement = QString{"UPDATE %1 SET %2 WHERE %3"}
                        .arg(entityMeta.tableName(), setStr, whereStr);

    QSqlQuery query = d->prepareAndExecute(statement, parameters);

    if (query.lastError().type() != QSqlError::NoError)
        return QOrmError{QOrm::Error::Provider, query.lastError().text()};

    if (query.numRowsAffected() != -1 && query.numRowsAffected() != 1)
        return QOrmError{QOrm::Error::UnsynchronizedEntity, QObject::tr("Unsynchronized entity")};

    return QOrmError{QOrm::Error::None, {}};
}

QOrmError QOrmSqlProvider::remove(QObject* entityInstance, const QMetaObject& qMetaObject)
{
    Q_D(QOrmSqlProvider);

    const QOrmEntityMetadata& entityMeta = d->entityMetadata(qMetaObject);

    QStringList whereList;
    QVariantMap parameters;

    for (const QOrmPropertyMapping& propertyMapping: entityMeta.propertyMappings())
    {
        parameters[':' % propertyMapping.tableFieldName()] =
                d->propertyValue(entityInstance, propertyMapping.classPropertyName());
        whereList.push_back(QString{"(%1 = :%1)"}.arg(propertyMapping.tableFieldName()));
    }

    auto statement = QString{"DELETE FROM %1 WHERE %2"}
                     .arg(entityMeta.tableName(), whereList.join(" AND "));

    QSqlQuery query = d->prepareAndExecute(statement, parameters);

    if (query.lastError().type() != QSqlError::NoError)
        return QOrmError{QOrm::Error::Provider, query.lastError().text()};

    if (query.numRowsAffected() != -1 && query.numRowsAffected() != 1)
        return QOrmError{QOrm::Error::UnsynchronizedEntity, QObject::tr("Unsynchronized entity")};

    return QOrmError{QOrm::Error::None, {}};
}

QOrmSqlConfiguration QOrmSqlProvider::configuration() const
{
    Q_D(const QOrmSqlProvider);

    return d->m_sqlConfiguration;
}

QSqlDatabase QOrmSqlProvider::database() const
{
    Q_D(const QOrmSqlProvider);

    return d->m_database;
}

QT_END_NAMESPACE
