/*
 * Copyright (C) 2019 Dmitriy Purgin <dmitriy.purgin@sequality.at>
 * Copyright (C) 2019 sequality software engineering e.U. <office@sequality.at>
 *
 * This file is part of QtOrm library.
 *
 * QtOrm is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * QtOrm is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with QtOrm.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "qormmetadatacache.h"
#include "qormglobal_p.h"
#include "qormmetadata_p.h"
#include "qormpropertymapping.h"

#include <QHash>
#include <QMetaObject>
#include <QMetaProperty>
#include <QSet>
#include <QVector>

class QOrmMetadataCachePrivate
{
    friend class QOrmMetadataCache;

    struct MappingDescriptor
    {
        QString classPropertyName;
        QString tableFieldName;
        bool isObjectId = false;
        bool isAutogenerated = false;
        const QOrmMetadata* referencedEntity = nullptr;
        bool isTransient = false;
    };

    std::unordered_map<QByteArray, QOrmMetadata> m_cache;

    QSet<QByteArray> m_underConstruction;
    QSet<QByteArray> m_constructed;

    const QOrmMetadata& get(const QMetaObject& metaObject);

    void initialize(const QByteArray& className, const QMetaObject& qMetaObject);

    MappingDescriptor mappingDescriptor(const QMetaObject& qMetaObject,
                                        const QMetaProperty& property);

    void validateConstructor(const QMetaObject& qMetaObject);

    template<typename Container>
    void validateCrossReferences(Container&& entityNames);
};

const QOrmMetadata& QOrmMetadataCachePrivate::get(const QMetaObject& qMetaObject)
{
    QByteArray className{qMetaObject.className()};

    if (m_cache.find(className) == std::end(m_cache))
    {
        initialize(className, qMetaObject);
    }

    return m_cache.at(className);
}

void QOrmMetadataCachePrivate::initialize(const QByteArray& className,
                                          const QMetaObject& qMetaObject)
{
    m_underConstruction.insert(className);

    // check whether the entity is creatable
    validateConstructor(qMetaObject);

    QOrmMetadataPrivate* data = new QOrmMetadataPrivate{qMetaObject};

    // cache the object before its actual initialization to resolve cyclic references inside the
    // mappings
    m_cache.emplace(className, QOrmMetadata{data});

    // initialize the private part of the cached object
    data->m_className = QString::fromUtf8(className);
    data->m_tableName = data->m_className;

    for (int i = 0; i < qMetaObject.propertyCount(); ++i)
    {
        QMetaProperty property = qMetaObject.property(i);

        // skip all properties of QObject
        if (property.enclosingMetaObject() == &QObject::staticMetaObject)
            continue;

        if (!property.isReadable() || !property.isWritable() || !property.hasNotifySignal() ||
            !property.notifySignal().isValid())
        {
            qFatal("QtOrm: The property %s::%s must have READ, WRITE, and NOTIFY declarations in "
                   "Q_PROPERTY().",
                   className.data(),
                   property.name());
        }

        MappingDescriptor descriptor = mappingDescriptor(qMetaObject, property);

        data->m_propertyMappings.emplace_back(m_cache.at(className),
                                              property,
                                              descriptor.classPropertyName,
                                              descriptor.tableFieldName,
                                              descriptor.isObjectId,
                                              descriptor.isAutogenerated,
                                              property.type(),
                                              descriptor.referencedEntity,
                                              descriptor.isTransient);
        auto idx = static_cast<int>(data->m_propertyMappings.size() - 1);

        data->m_classPropertyMappingIndex.insert(descriptor.classPropertyName, idx);
        data->m_tableFieldMappingIndex.insert(descriptor.tableFieldName, idx);

        if (descriptor.isObjectId)
            data->m_objectIdPropertyMappingIdx = idx;
    }

    m_underConstruction.remove(className);
    m_constructed.insert(className);

    // After all entity metadata is gathered, check their cross-reference consistency
    if (m_underConstruction.empty())
        validateCrossReferences(m_constructed);
}

QOrmMetadataCachePrivate::MappingDescriptor QOrmMetadataCachePrivate::mappingDescriptor(
    const QMetaObject& qMetaObject,
    const QMetaProperty& property)
{
    MappingDescriptor descriptor;

    descriptor.classPropertyName = QString::fromUtf8(property.name());
    descriptor.tableFieldName = QString::fromUtf8(property.name()).toLower();
    descriptor.isObjectId =
        descriptor.classPropertyName.compare(QLatin1String{"id"}, Qt::CaseInsensitive) == 0;
    descriptor.isAutogenerated = descriptor.isObjectId;

    // Check if this is one-to-many or many-to-one relation.
    // One-to-many relation will have a container in type. If so, extract the contained
    // type.
    if (property.type() == QVariant::UserType)
    {
        auto typeName = QByteArray{property.typeName()};

        static auto aggregatePrefixes = QVector<QByteArray>{"QVector<", "QSet<"};

        for (const auto& prefix : aggregatePrefixes)
        {
            if (typeName.startsWith(prefix))
            {
                typeName = typeName.mid(prefix.length());
                break;
            }
        }

        if (typeName.endsWith("*>"))
        {
            typeName.chop(1);
            descriptor.tableFieldName.clear();
            descriptor.isTransient = true;
        }
        else
        {
            descriptor.tableFieldName += "_id";
            descriptor.isTransient = false;
        }

        if (property.userType() == QMetaType::UnknownType)
        {
            if (typeName.endsWith('*'))
                typeName.chop(1);

            qFatal("QtOrm: An unregistered type %s is used in %s::%s. If this is a referenced "
                   "entity register it with qRegisterOrmEntity<%s>()",
                   typeName.data(),
                   qMetaObject.className(),
                   property.name(),
                   typeName.data());
        }

        const QMetaObject* referencedMeta = QMetaType::metaObjectForType(QMetaType::type(typeName));

        if (referencedMeta == nullptr)
        {
            qFatal("QtOrm: Cannot deduce ORM entity from type %s used in %s::%s",
                   property.typeName(),
                   qMetaObject.className(),
                   property.name());
        }

        descriptor.referencedEntity = &get(*referencedMeta);
        Q_ASSERT(descriptor.referencedEntity != nullptr);
    }

    return descriptor;
}

void QOrmMetadataCachePrivate::validateConstructor(const QMetaObject& qMetaObject)
{
    bool hasError = false;

    if (qMetaObject.constructorCount() == 0)
    {
        hasError = true;
    }

    for (int i = 0; i < qMetaObject.constructorCount() && !hasError; ++i)
    {
        QMetaMethod ctor = qMetaObject.constructor(i);

        hasError = (ctor.access() != QMetaMethod::Public) || (ctor.parameterCount() > 1) ||
                   (ctor.parameterCount() == 1 && ctor.parameterTypes().front() != "QObject*");
    }

    if (hasError)
    {
        qFatal("QtOrm: Entity %s requires a metaobject-invokable public default constructor, "
               "e.g.: Q_INVOKABLE explicit %s(QObject* parent = nullptr) = default;",
               qMetaObject.className(),
               qMetaObject.className());
    }
}

template<typename Container>
void QOrmMetadataCachePrivate::validateCrossReferences(Container&& entityNames)
{
    for (const QByteArray& entityClassName : entityNames)
    {
        Q_ASSERT(m_cache.find(entityClassName) != std::end(m_cache));

        for (const QOrmPropertyMapping& mapping : m_cache.at(entityClassName).propertyMappings())
        {
            if (!mapping.isReference())
                continue;

            // If the property is a container of referenced entities, check that there is a
            // corresponding pointer on the other side of the relation
            // E.g.: if entity A has a property QVector<B*>, then the entity B should have a
            // property A*.
            if (mapping.isTransient())
            {
                const auto& referencedMappings = mapping.referencedEntity()->propertyMappings();

                auto it = std::find_if(std::cbegin(referencedMappings),
                                       std::cend(referencedMappings),
                                       [entityClassName](const QOrmPropertyMapping& mapping) {
                                           // require pointer to this entity
                                           return mapping.isReference() &&
                                                  mapping.referencedEntity()->className() ==
                                                      entityClassName;
                                       });

                if (it == std::cend(referencedMappings))
                {
                    qFatal("QtOrm: Entity %s referenced in %s::%s must have a back-reference "
                           "to %s. "
                           "Declare a Q_PROPERTY(%s* ...) in %s.",
                           mapping.referencedEntity()->className().toUtf8().data(),
                           entityClassName.data(),
                           mapping.classPropertyName().toUtf8().data(),
                           entityClassName.data(),
                           entityClassName.data(),
                           mapping.referencedEntity()->className().toUtf8().data());
                }
            }
            // Many-to-one relations. Check that the related entity has object ID
            else if (mapping.referencedEntity()->objectIdMapping() == nullptr)
            {
                qFatal("QtOrm: Entity %s referenced in %s::%s must have an object ID property",
                       mapping.referencedEntity()->className().toUtf8().data(),
                       entityClassName.data(),
                       mapping.classPropertyName().toUtf8().data());
            }
        }
    }
}

QOrmMetadataCache::QOrmMetadataCache()
    : d{new QOrmMetadataCachePrivate}
{    
}

QOrmMetadataCache::QOrmMetadataCache(QOrmMetadataCache&&) = default;

QOrmMetadataCache& QOrmMetadataCache::operator=(QOrmMetadataCache&&) = default;

QOrmMetadataCache::~QOrmMetadataCache() = default;

const QOrmMetadata& QOrmMetadataCache::operator[](const QMetaObject& qMetaObject)
{
    return d->get(qMetaObject);
}
