#include "qormmetadatacache.h"
#include "qormglobal_p.h"
#include "qormmetadata_p.h"
#include "qormpropertymapping.h"

#include <QHash>
#include <QMetaObject>
#include <QMetaProperty>
#include <QVector>

class QOrmMetadataCachePrivate
{
    friend class QOrmMetadataCache;

    std::unordered_map<QByteArray, QOrmMetadata> m_cache;

    void initialize(QOrmMetadataCache* cache,
                    const QByteArray& className,
                    const QMetaObject& qMetaObject);
};

void QOrmMetadataCachePrivate::initialize(QOrmMetadataCache* cache,
                                          const QByteArray& className,
                                          const QMetaObject& qMetaObject)
{
    QOrmMetadataPrivate* data = new QOrmMetadataPrivate{qMetaObject};

    // cache the object before its actual initialization to resolve cyclic references inside the
    // mappings
    m_cache.emplace(className, QOrmMetadata{data});

    // initialize the private part of the cached object
    data->m_className = QString::fromUtf8(className);
    data->m_tableName = data->m_className;

    for (int i = 0; i < qMetaObject.propertyCount(); ++i)
    {
        QMetaProperty property = qMetaObject.property(i);

        // skip all properties of QObject
        if (property.enclosingMetaObject() == &QObject::staticMetaObject)
            continue;

        auto classPropertyName = QString::fromUtf8(property.name());
        auto tableFieldName = QString::fromUtf8(property.name()).toLower();
        auto isObjectId =
            tableFieldName.compare(property.name(), QLatin1String{"id"}, Qt::CaseInsensitive) == 0;
        bool isAutogenerated = isObjectId;
        const QOrmMetadata* referencedEntity = nullptr;
        bool isTransient = false;

        if (property.type() == QVariant::UserType)
        {
            if (property.userType() == QMetaType::UnknownType)
            {
                qFatal("QtORM: The type %s is used in an ORM entity but was not registered using "
                       "qRegisterMetaType<%s>()",
                       property.typeName(),
                       property.typeName());
            }

            auto typeName = QByteArray{property.typeName()};

            static auto aggregatePrefixes = QVector<QByteArray>{"QVector<", "QSet<", "QList<"};

            for (const auto& prefix : aggregatePrefixes)
            {
                if (typeName.startsWith(prefix))
                {
                    typeName = typeName.mid(prefix.length());
                    break;
                }
            }

            if (typeName.endsWith("*>"))
            {
                typeName.chop(1);
                isTransient = true;
            }
            else
            {
                tableFieldName += "_id";
                isTransient = false;
            }

            const QMetaObject* referencedMeta =
                QMetaType::metaObjectForType(QMetaType::type(typeName));

            if (referencedMeta == nullptr)
            {
                qFatal("QtORM: Cannot deduce ORM entity from type %s used in %s::%s",
                       property.typeName(),
                       qMetaObject.className(),
                       property.name());
            }

            referencedEntity = &cache->get(*referencedMeta);
            Q_ASSERT(referencedEntity != nullptr);

            if (referencedEntity->objectIdMapping() == nullptr)
            {
                qFatal("QtORM: Entity %s referenced in %s::%s must have an object ID property",
                       referencedEntity->className().toUtf8().data(),
                       qMetaObject.className(),
                       property.name());
            }
        }

        data->m_propertyMappings.emplace_back(m_cache.at(className),
                                              classPropertyName,
                                              tableFieldName,
                                              isObjectId,
                                              isAutogenerated,
                                              property.type(),
                                              referencedEntity,
                                              isTransient);
        auto idx = static_cast<int>(data->m_propertyMappings.size() - 1);

        data->m_classPropertyMappingIndex.insert(classPropertyName, idx);
        data->m_tableFieldMappingIndex.insert(tableFieldName, idx);

        if (isObjectId)
            data->m_objectIdPropertyMappingIdx = idx;
    }
}

QOrmMetadataCache::QOrmMetadataCache()
    : d{new QOrmMetadataCachePrivate}
{    
}

QOrmMetadataCache::QOrmMetadataCache(QOrmMetadataCache&&) = default;

QOrmMetadataCache& QOrmMetadataCache::operator=(QOrmMetadataCache&&) = default;

QOrmMetadataCache::~QOrmMetadataCache() = default;

const QOrmMetadata& QOrmMetadataCache::operator[](const QMetaObject& qMetaObject)
{
    QByteArray className{qMetaObject.className()};

    if (d->m_cache.find(className) == std::end(d->m_cache))
    {
        d->initialize(this, className, qMetaObject);
    }

    return d->m_cache.at(className);
}
