#include "qormmetadatacache.h"
#include "qormglobal_p.h"
#include "qormmetadata_p.h"
#include "qormpropertymapping.h"

#include <QHash>
#include <QMetaObject>
#include <QMetaProperty>
#include <QVector>

class QOrmMetadataCachePrivate
{
    friend class QOrmMetadataCache;

    std::unordered_map<QByteArray, QOrmMetadata> m_cache;

    void initialize(QOrmMetadataCache* cache,
                    const QByteArray& className,
                    const QMetaObject& qMetaObject);
};

void QOrmMetadataCachePrivate::initialize(QOrmMetadataCache* cache,
                                          const QByteArray& className,
                                          const QMetaObject& qMetaObject)
{
    QOrmMetadataPrivate* data = new QOrmMetadataPrivate{qMetaObject};

    // cache the object before its actual initialization to resolve cyclic references inside the
    // mappings
    m_cache.emplace(className, QOrmMetadata{data});

    // initialize the private part of the cached object
    data->m_className = QString::fromUtf8(className);
    data->m_tableName = data->m_className;

    for (int i = 0; i < qMetaObject.propertyCount(); ++i)
    {
        QMetaProperty property = qMetaObject.property(i);

        // skip all properties of QObject
        if (property.enclosingMetaObject() == &QObject::staticMetaObject)
            continue;

        if (!property.isReadable() || !property.isWritable() || !property.hasNotifySignal() ||
            !property.notifySignal().isValid())
        {
            qFatal("QtOrm: The property %s::%s must have READ, WRITE, and NOTIFY declarations in "
                   "Q_PROPERTY().",
                   className.data(),
                   property.name());
        }

        auto classPropertyName = QString::fromUtf8(property.name());
        auto tableFieldName = QString::fromUtf8(property.name()).toLower();
        auto isObjectId =
            tableFieldName.compare(property.name(), QLatin1String{"id"}, Qt::CaseInsensitive) == 0;
        bool isAutogenerated = isObjectId;
        const QOrmMetadata* referencedEntity = nullptr;
        bool isTransient = false;

        // Reference to another entity
        if (property.type() == QVariant::UserType)
        {
            // Check if this is one-to-many or many-to-one relation.
            // One-to-many relation will have a container in type. If so, extract the contained
            // type.

            auto typeName = QByteArray{property.typeName()};

            static auto aggregatePrefixes = QVector<QByteArray>{"QVector<", "QSet<", "QList<"};

            for (const auto& prefix : aggregatePrefixes)
            {
                if (typeName.startsWith(prefix))
                {
                    typeName = typeName.mid(prefix.length());
                    break;
                }
            }

            if (typeName.endsWith("*>"))
            {
                typeName.chop(1);
                isTransient = true;
            }
            else
            {
                tableFieldName += "_id";
                isTransient = false;
            }

            if (property.userType() == QMetaType::UnknownType)
            {
                if (typeName.endsWith('*'))
                    typeName.chop(1);

                qFatal("QtOrm: An unregistered type %s is used in %s::%s. If this is a referenced "
                       "entity register it with qRegisterOrmEntity<%s>()",
                       typeName.data(),
                       qMetaObject.className(),
                       property.name(),
                       typeName.data());
            }

            const QMetaObject* referencedMeta =
                QMetaType::metaObjectForType(QMetaType::type(typeName));

            if (referencedMeta == nullptr)
            {
                qFatal("QtOrom: Cannot deduce ORM entity from type %s used in %s::%s",
                       property.typeName(),
                       qMetaObject.className(),
                       property.name());
            }

            referencedEntity = &cache->get(*referencedMeta);
            Q_ASSERT(referencedEntity != nullptr);

            // for one-to-many relation: Check that there is the corresponding field on the other
            // side
            if (isTransient)
            {
                auto it =
                    std::find_if(std::cbegin(referencedEntity->propertyMappings()),
                                 std::cend(referencedEntity->propertyMappings()),
                                 [cache, qMetaObject](const QOrmPropertyMapping& mapping) {
                                     return mapping.isReference() &&
                                            mapping.referencedEntity() == &cache->get(qMetaObject);
                                 });

                if (it == std::cend(referencedEntity->propertyMappings()))
                {
                    qFatal(
                        "QtOrm: Entity %s referenced in %s::%s must have a back-reference to %s. "
                        "Declare a Q_PROPERTY(%s* ...) in %s.",
                        referencedEntity->className().toUtf8().data(),
                        className.data(),
                        property.name(),
                        className.data(),
                        className.data(),
                        referencedEntity->className().toUtf8().data());
                }
            }
            // Many-to-one relations. Check that the related entity has object ID
            else if (referencedEntity->objectIdMapping() == nullptr)
            {
                qFatal("QtOrm: Entity %s referenced in %s::%s must have an object ID property",
                       referencedEntity->className().toUtf8().data(),
                       qMetaObject.className(),
                       property.name());
            }
        }

        data->m_propertyMappings.emplace_back(m_cache.at(className),
                                              property,
                                              classPropertyName,
                                              tableFieldName,
                                              isObjectId,
                                              isAutogenerated,
                                              property.type(),
                                              referencedEntity,
                                              isTransient);
        auto idx = static_cast<int>(data->m_propertyMappings.size() - 1);

        data->m_classPropertyMappingIndex.insert(classPropertyName, idx);
        data->m_tableFieldMappingIndex.insert(tableFieldName, idx);

        if (isObjectId)
            data->m_objectIdPropertyMappingIdx = idx;
    }
}

QOrmMetadataCache::QOrmMetadataCache()
    : d{new QOrmMetadataCachePrivate}
{    
}

QOrmMetadataCache::QOrmMetadataCache(QOrmMetadataCache&&) = default;

QOrmMetadataCache& QOrmMetadataCache::operator=(QOrmMetadataCache&&) = default;

QOrmMetadataCache::~QOrmMetadataCache() = default;

const QOrmMetadata& QOrmMetadataCache::operator[](const QMetaObject& qMetaObject)
{
    QByteArray className{qMetaObject.className()};

    if (d->m_cache.find(className) == std::end(d->m_cache))
    {
        d->initialize(this, className, qMetaObject);
    }

    return d->m_cache.at(className);
}
