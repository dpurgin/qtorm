/*
 * Copyright (C) 2019-2021 Dmitriy Purgin <dpurgin@gmail.com>
 * Copyright (C) 2019 Dmitriy Purgin <dmitriy.purgin@sequality.at>
 * Copyright (C) 2019 sequality software engineering e.U. <office@sequality.at>
 *
 * This file is part of QtOrm library.
 *
 * QtOrm is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * QtOrm is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with QtOrm.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "qormmetadatacache.h"
#include "qormglobal_p.h"
#include "qormmetadata_p.h"
#include "qormpropertymapping.h"

#include <QHash>
#include <QLoggingCategory>
#include <QMetaObject>
#include <QMetaProperty>
#include <QSet>
#include <QVector>

#include <optional>

namespace
{
    enum class KeywordId
    {
        Table,
        Property,
        Column,
        Autogenerated,
        Identity,
        Transient
    };

    inline uint qHash(KeywordId value) { return ::qHash(static_cast<int>(value)); }

    struct KeywordDescriptor
    {
        KeywordId id;
        QLatin1String token;
    };

    using UserMetadata = QHash<KeywordId, QVariant>;

    struct KeywordPosition
    {
        int pos{-1};
        const KeywordDescriptor* keyword{nullptr};
    };

    const KeywordDescriptor Keywords[] = {{KeywordId::Column, QLatin1String("COLUMN")},
                                          {KeywordId::Identity, QLatin1String("IDENTITY")},
                                          {KeywordId::Transient, QLatin1String("TRANSIENT")},
                                          {KeywordId::Autogenerated,
                                           QLatin1String("AUTOGENERATED")}};

    KeywordPosition findNextKeyword(const QString& data, int startFrom)
    {
        for (int i = startFrom; i < data.size(); ++i)
        {
            if (data[i].isUpper())
            {
                for (auto it = std::cbegin(Keywords); it != std::cend(Keywords); ++it)
                {
                    if (data.midRef(i, it->token.size()) == it->token)
                    {
                        return {i, it};
                    }
                }
            }
        }

        return {-1, nullptr};
    }

    template<typename T>
    struct ExtractResult
    {
        T value;
        KeywordPosition nextKeyword;
    };

    template<typename T>
    [[nodiscard]] auto extracted(T&& value, KeywordPosition nextKeyword)
    {
        return ExtractResult<T>{std::forward<T>(value), nextKeyword};
    }

    [[nodiscard]] ExtractResult<QString> extractString(const QString& data, int pos)
    {
        auto nextKeyword = findNextKeyword(data, pos);
        int len = nextKeyword.pos == -1 ? data.size() - pos : nextKeyword.pos - pos;

        return extracted(data.mid(pos, len), nextKeyword);
    }

    [[nodiscard]] std::optional<ExtractResult<std::optional<bool>>>
    extractBoolean(const QString& data, int pos)
    {
        auto [str, nextKeyword] = extractString(data, pos);

        if (str == QLatin1String("true"))
        {
            return extracted(std::make_optional(true), nextKeyword);
        }
        else if (str == QLatin1String("false"))
        {
            return extracted(std::make_optional(false), nextKeyword);
        }
        else if (str.isEmpty())
        {
            return extracted(std::optional<bool>{std::nullopt}, nextKeyword);
        }
        else
        {
            return std::nullopt;
        }
    }

    [[nodiscard]] UserMetadata extractClassInfo(const QMetaObject& qMetaObject, QString data)
    {
        UserMetadata ormClassInfo;

        static const QLatin1String TableStr{"TABLE"};

        if (data.startsWith(TableStr))
        {
            QString tableName = data.mid(TableStr.size());

            if (tableName.isEmpty())
            {
                qFatal(
                    "QtOrm: syntax error in %s: Q_ORM_CLASS(TABLE <table name>) requires a string "
                    "argument.",
                    qMetaObject.className());
            }

            ormClassInfo.insert(KeywordId::Table, tableName);
        }
        else
        {
            qCWarning(qtorm,
                      "QtOrm: syntax error in %s: unexpected token in Q_ORM_CLASS: %s",
                      qMetaObject.className(),
                      qPrintable(data));
        }

        return ormClassInfo;
    }

    [[nodiscard]] UserMetadata extractPropertyInfo(const QMetaObject& qMetaObject, QString data)
    {
        // Q_CLASSINFO removes whitespaces from its arguments. So a declaration like
        //    Q_ORM_PROPERTY(id COLUMN province_id AUTOGENERATED IDENTITY)
        // turns into "idCOLUMNprovince_idAUTOGENERATEDIDENTITY".
        //
        // First, try to find the first keyword in the string. Everything prior to its position is
        // considered to be a property name.

        auto keywordPosition = findNextKeyword(data, 0);

        if (keywordPosition.pos == -1)
        {
            qFatal("QtOrm: syntax error in %s: cannot find any QtOrm keywords in a Q_ORM_PROPERTY",
                   qMetaObject.className());
        }

        QString propertyName = data.mid(0, keywordPosition.pos);

        UserMetadata ormPropertyInfo;
        ormPropertyInfo.insert(KeywordId::Property, propertyName);

        // Check that the property exists in the metadata.

        int i = 0;
        for (; i < qMetaObject.propertyCount() && qMetaObject.property(i).name() != propertyName;
             ++i)
            ;

        if (i == qMetaObject.propertyCount())
        {
            qFatal("QtOrm: Q_ORM_PROPERTY(%s ...) does not have a corresponding Q_PROPERTY(%s ...) "
                   "in %s",
                   qPrintable(propertyName),
                   qPrintable(propertyName),
                   qMetaObject.className());
        }

        // Evaluate the current keyword and read its argument from the string until the next keyword
        // or the end of the string.

        while (keywordPosition.pos != -1)
        {
            int pos = keywordPosition.pos + keywordPosition.keyword->token.size();

            if (keywordPosition.keyword->id == KeywordId::Column)
            {
                auto extractResult = extractString(data, pos);

                QString columnName = extractResult.value;
                keywordPosition = extractResult.nextKeyword;

                if (!columnName.isEmpty())
                {
                    ormPropertyInfo.insert(KeywordId::Column, columnName);
                }
                else
                {
                    qFatal("QtOrm: syntax error in %s: Q_ORM_PROPERTY(%s COLUMN <column name>) "
                           "requires a string argument.",
                           qMetaObject.className(),
                           qPrintable(propertyName));
                }
            }
            else if (keywordPosition.keyword->id == KeywordId::Identity)
            {
                auto extractResult = extractBoolean(data, pos);

                if (!extractResult.has_value())
                {
                    qFatal("QtOrm: syntax error in %s in Q_ORM_PROPERTY(%s ...) after IDENTITY",
                           qMetaObject.className(),
                           qPrintable(propertyName));
                }

                std::optional<bool> isIdentity = extractResult->value;
                keywordPosition = extractResult->nextKeyword;

                ormPropertyInfo.insert(KeywordId::Identity, isIdentity.value_or(true));
            }
            else if (keywordPosition.keyword->id == KeywordId::Transient)
            {
                auto extractResult = extractBoolean(data, pos);

                if (!extractResult.has_value())
                {
                    qFatal("QtOrm: syntax error in %s in Q_ORM_PROPERTY(%s ...) after TRANSIENT",
                           qMetaObject.className(),
                           qPrintable(propertyName));
                }

                std::optional<bool> isTransient = extractResult->value;
                keywordPosition = extractResult->nextKeyword;

                ormPropertyInfo.insert(KeywordId::Transient, isTransient.value_or(true));
            }
            else if (keywordPosition.keyword->id == KeywordId::Autogenerated)
            {
                auto extractResult = extractBoolean(data, pos);

                if (!extractResult.has_value())
                {
                    qFatal(
                        "QtOrm: syntax error in %s in Q_ORM_PROPERTY(%s ...) after AUTOGENERATED",
                        qMetaObject.className(),
                        qPrintable(propertyName));
                }

                std::optional<bool> isAutogenerated = extractResult->value;
                keywordPosition = extractResult->nextKeyword;

                ormPropertyInfo.insert(KeywordId::Autogenerated, isAutogenerated.value_or(true));
            }
        }

        return ormPropertyInfo;
    }
} // namespace

class QOrmMetadataCachePrivate
{
    friend class QOrmMetadataCache;

    struct MappingDescriptor
    {
        QString classPropertyName;
        QString tableFieldName;
        bool isObjectId = false;
        bool isAutogenerated = false;
        const QOrmMetadata* referencedEntity = nullptr;
        bool isTransient = false;
    };

    std::unordered_map<QByteArray, QOrmMetadata> m_cache;

    QSet<QByteArray> m_underConstruction;
    QSet<QByteArray> m_constructed;

    [[nodiscard]] const QOrmMetadata& get(const QMetaObject& metaObject);

    void initialize(const QByteArray& className, const QMetaObject& qMetaObject);

    [[nodiscard]] MappingDescriptor mappingDescriptor(
        const QMetaObject& qMetaObject,
        const QMetaProperty& property,
        const std::optional<UserMetadata>& userPropertyMetadata);

    void validateConstructor(const QMetaObject& qMetaObject);

    template<typename Container>
    void validateCrossReferences(Container&& entityNames);
};

const QOrmMetadata& QOrmMetadataCachePrivate::get(const QMetaObject& qMetaObject)
{
    QByteArray className{qMetaObject.className()};

    if (m_cache.find(className) == std::end(m_cache))
    {
        initialize(className, qMetaObject);
    }

    return m_cache.at(className);
}

void QOrmMetadataCachePrivate::initialize(const QByteArray& className,
                                          const QMetaObject& qMetaObject)
{
    m_underConstruction.insert(className);

    // check whether the entity is creatable
    validateConstructor(qMetaObject);

    QOrmMetadataPrivate* data = new QOrmMetadataPrivate{qMetaObject};

    // cache the object before its actual initialization to resolve cyclic references inside the
    // mappings
    m_cache.emplace(className, QOrmMetadata{data});

    UserMetadata ormClassInfo;
    QHash<QString, UserMetadata> ormPropertyInfo;

    for (int i = 0; i < qMetaObject.classInfoCount(); ++i)
    {
        QMetaClassInfo qtClassInfo = qMetaObject.classInfo(i);

        if (qstrcmp(qtClassInfo.name(), "QtOrmClassInfo") == 0)
        {
            ormClassInfo = extractClassInfo(qMetaObject, qtClassInfo.value());
        }
        else if (qstrcmp(qtClassInfo.name(), "QtOrmPropertyInfo") == 0)
        {
            UserMetadata propertyInfo = extractPropertyInfo(qMetaObject, qtClassInfo.value());

            Q_ASSERT(propertyInfo.contains(KeywordId::Property));
            ormPropertyInfo.insert(propertyInfo[KeywordId::Property].toString(), propertyInfo);
        }
    }

    // initialize the private part of the cached object
    data->m_className = QString::fromUtf8(qMetaObject.className());
    data->m_tableName =
        ormClassInfo.value(KeywordId::Table, QVariant::fromValue(data->m_className)).toString();

    for (int i = 0; i < qMetaObject.propertyCount(); ++i)
    {
        QMetaProperty property = qMetaObject.property(i);

        // skip all properties of QObject
        if (property.enclosingMetaObject() == &QObject::staticMetaObject)
            continue;

        QString propertyName = QString::fromUtf8(property.name());
        std::optional<UserMetadata> userPropertyMetadata =
            ormPropertyInfo.contains(propertyName)
                ? std::make_optional(ormPropertyInfo.value(propertyName))
                : std::nullopt;

        MappingDescriptor descriptor =
            mappingDescriptor(qMetaObject, property, userPropertyMetadata);

        if (!descriptor.isTransient &&
            (!property.isReadable() || !property.isWritable() || !property.hasNotifySignal() ||
             !property.notifySignal().isValid()))
        {
            qFatal("QtOrm: The property %s::%s must have READ, WRITE, and NOTIFY declarations in "
                   "Q_PROPERTY().",
                   className.data(),
                   property.name());
        }

        if (descriptor.isTransient && descriptor.isObjectId)
        {
            qFatal("QtOrm: The property %s::%s cannot be marked TRANSIENT and IDENTITY at the same "
                   "time.",
                   qPrintable(className),
                   property.name());
        }

        if (descriptor.isAutogenerated && !descriptor.isObjectId)
        {
            qFatal("QtOrm: The property %s::%s cannot be marked AUTOGENERATED without IDENTITY.",
                   qPrintable(className),
                   property.name());
        }

        data->m_propertyMappings.emplace_back(m_cache.at(className),
                                              property,
                                              descriptor.classPropertyName,
                                              descriptor.tableFieldName,
                                              descriptor.isObjectId,
                                              descriptor.isAutogenerated,
                                              property.type(),
                                              descriptor.referencedEntity,
                                              descriptor.isTransient);
        auto idx = static_cast<int>(data->m_propertyMappings.size() - 1);

        data->m_classPropertyMappingIndex.insert(descriptor.classPropertyName, idx);
        data->m_tableFieldMappingIndex.insert(descriptor.tableFieldName, idx);

        if (descriptor.isObjectId)
            data->m_objectIdPropertyMappingIdx = idx;
    }

    m_underConstruction.remove(className);
    m_constructed.insert(className);

    // After all entity metadata is gathered, check their cross-reference consistency
    if (m_underConstruction.empty())
        validateCrossReferences(m_constructed);
}

QOrmMetadataCachePrivate::MappingDescriptor QOrmMetadataCachePrivate::mappingDescriptor(
    const QMetaObject& qMetaObject,
    const QMetaProperty& property,
    const std::optional<UserMetadata>& userPropertyMetadata)
{
    Q_ASSERT(!userPropertyMetadata.has_value() ||
             userPropertyMetadata->value(KeywordId::Property) == property.name());

    MappingDescriptor descriptor;

    QString tableFieldName = QString::fromUtf8(property.name()).toLower();
    bool isObjectId = qstricmp(property.name(), "id") == 0;
    bool isAutogenerated = isObjectId;
    bool isTransient = !property.isStored();

    // Check if defaults are overridden by the user property metadata
    if (userPropertyMetadata.has_value())
    {
        if (userPropertyMetadata->contains(KeywordId::Column))
        {
            tableFieldName = userPropertyMetadata->value(KeywordId::Column).toString();
            Q_ASSERT(!tableFieldName.isEmpty());
        }

        if (userPropertyMetadata->contains(KeywordId::Identity))
        {
            isObjectId = userPropertyMetadata->value(KeywordId::Identity).toBool();
        }

        if (userPropertyMetadata->contains(KeywordId::Autogenerated))
        {
            isAutogenerated = userPropertyMetadata->value(KeywordId::Autogenerated).toBool();
        }

        if (userPropertyMetadata->contains(KeywordId::Transient))
        {
            isTransient = userPropertyMetadata->value(KeywordId::Transient).toBool();
        }
    }

    descriptor.classPropertyName = QString::fromUtf8(property.name());
    descriptor.tableFieldName = tableFieldName;
    descriptor.isObjectId = isObjectId;
    descriptor.isAutogenerated = isAutogenerated;
    descriptor.isTransient = isTransient;

    // Check if this is one-to-many or many-to-one relation.
    // One-to-many relation will have a container in type. If so, extract the contained
    // type.
    if (property.type() == QVariant::UserType)
    {
        auto typeName = QByteArray{property.typeName()};

        static auto aggregatePrefixes = QVector<QByteArray>{"QVector<", "QSet<"};

        for (const auto& prefix : aggregatePrefixes)
        {
            if (typeName.startsWith(prefix))
            {
                typeName = typeName.mid(prefix.length());
                break;
            }
        }

        if (typeName.endsWith("*>"))
        {
            typeName.chop(1);
            descriptor.tableFieldName.clear();
            descriptor.isTransient = true;
        }
        else
        {
            descriptor.tableFieldName += "_id";
            descriptor.isTransient = false;
        }

        if (property.userType() == QMetaType::UnknownType)
        {
            if (typeName.endsWith('*'))
                typeName.chop(1);

            qFatal("QtOrm: An unregistered type %s is used in %s::%s. If this is a referenced "
                   "entity, it should be registered with qRegisterOrmEntity<%s>(). If this is a "
                   "type alias for a container type, this is currently not supported.",
                   typeName.data(),
                   qMetaObject.className(),
                   property.name(),
                   typeName.data());
        }

        const QMetaObject* referencedMeta = QMetaType::metaObjectForType(QMetaType::type(typeName));

        if (referencedMeta == nullptr)
        {
            qFatal("QtOrm: Cannot deduce ORM entity from type %s used in %s::%s",
                   property.typeName(),
                   qMetaObject.className(),
                   property.name());
        }

        descriptor.referencedEntity = &get(*referencedMeta);
        Q_ASSERT(descriptor.referencedEntity != nullptr);
    }

    return descriptor;
}

void QOrmMetadataCachePrivate::validateConstructor(const QMetaObject& qMetaObject)
{
    bool hasError = false;

    if (qMetaObject.constructorCount() == 0)
    {
        hasError = true;
    }

    for (int i = 0; i < qMetaObject.constructorCount() && !hasError; ++i)
    {
        QMetaMethod ctor = qMetaObject.constructor(i);

        hasError = (ctor.access() != QMetaMethod::Public) || (ctor.parameterCount() > 1) ||
                   (ctor.parameterCount() == 1 && ctor.parameterTypes().front() != "QObject*");
    }

    if (hasError)
    {
        qFatal("QtOrm: Entity %s requires a metaobject-invokable public default constructor, "
               "e.g.: Q_INVOKABLE explicit %s(QObject* parent = nullptr): QObject{parent} {}",
               qMetaObject.className(),
               qMetaObject.className());
    }
}

template<typename Container>
void QOrmMetadataCachePrivate::validateCrossReferences(Container&& entityNames)
{
    for (const QByteArray& entityClassName : entityNames)
    {
        Q_ASSERT(m_cache.find(entityClassName) != std::end(m_cache));

        for (const QOrmPropertyMapping& mapping : m_cache.at(entityClassName).propertyMappings())
        {
            if (!mapping.isReference())
                continue;

            // If the property is a container of referenced entities, check that there is a
            // corresponding pointer on the other side of the relation
            // E.g.: if entity A has a property QVector<B*>, then the entity B should have a
            // property A*.
            if (mapping.isTransient())
            {
                const auto& referencedMappings = mapping.referencedEntity()->propertyMappings();

                auto it = std::find_if(std::cbegin(referencedMappings),
                                       std::cend(referencedMappings),
                                       [entityClassName](const QOrmPropertyMapping& mapping) {
                                           // require pointer to this entity
                                           return mapping.isReference() &&
                                                  mapping.referencedEntity()->className() ==
                                                      entityClassName;
                                       });

                if (it == std::cend(referencedMappings))
                {
                    qFatal("QtOrm: Entity %s referenced in %s::%s must have a back-reference "
                           "to %s. "
                           "Declare a Q_PROPERTY(%s* ...) in %s.",
                           mapping.referencedEntity()->className().toUtf8().data(),
                           entityClassName.data(),
                           mapping.classPropertyName().toUtf8().data(),
                           entityClassName.data(),
                           entityClassName.data(),
                           mapping.referencedEntity()->className().toUtf8().data());
                }
            }
            // Many-to-one relations. Check that the related entity has object ID
            else if (mapping.referencedEntity()->objectIdMapping() == nullptr)
            {
                qFatal("QtOrm: Entity %s referenced in %s::%s must have an object ID property",
                       mapping.referencedEntity()->className().toUtf8().data(),
                       entityClassName.data(),
                       mapping.classPropertyName().toUtf8().data());
            }
        }
    }
}

QOrmMetadataCache::QOrmMetadataCache()
    : d{new QOrmMetadataCachePrivate}
{    
}

QOrmMetadataCache::QOrmMetadataCache(QOrmMetadataCache&&) = default;

QOrmMetadataCache& QOrmMetadataCache::operator=(QOrmMetadataCache&&) = default;

QOrmMetadataCache::~QOrmMetadataCache() = default;

const QOrmMetadata& QOrmMetadataCache::operator[](const QMetaObject& qMetaObject)
{
    return d->get(qMetaObject);
}
